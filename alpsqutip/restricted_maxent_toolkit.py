"""
Functions used to run MaxEnt simulations.
"""

import logging
from typing import Callable, List

import numpy as np
import qutip
from scipy import linalg

from alpsqutip.operators import (
    LocalOperator,
    OneBodyOperator,
    Operator,
    ProductOperator,
    QutipOperator,
    ScalarOperator,
    SumOperator,
)
from alpsqutip.operators.functions import anticommutator, commutator
from alpsqutip.operators.states import (
    GibbsProductDensityOperator,
    ProductDensityOperator,
)

# function used to safely and robustly map K-states to states
from alpsqutip.qutip_tools.tools import schmidt_dec_firsts_last_qutip_operator


def fetch_covar_scalar_product(sigma):
    """
    Returns a scalar product function based on the covariance of a density
    operator.

    The scalar product for two operators op1 and op2 is defined as:
        0.5 * Tr(sigma * {op1†, op2}),
    where sigma is a density operator, {op1†, op2} is the anticommutator of
    the Hermitian conjugate of op1 and op2, and Tr denotes the trace.

    Parameters:
        sigma: The density operator (quantum state) used to define the scalar
        product.

    Returns:
        A function that takes two operators (op1, op2) and computes their
        covariance-based scalar product.
    """
    return lambda op1, op2: 0.5 * (sigma * anticommutator(op1.dag(), op2)).tr()


def build_hierarchical_basis(generator, seed_op, deep) -> List[Operator]:
    """
    Constructs a hierarchical basis of operators, formed from iterated
    commutators of a seed operator.

    Parameters:
        generator: The generator operator (e.g., a Hamiltonian).
                    It should be passed as a QutipAlps operator
                    (not Qutip.qobj)
        seed_op: The initial seed operator for generating the basis.
                 If None, the function will return an empty list.
        deep: An integer indicating the depth of the hierarchy
        (number of iterated commutators).

    Returns:
        A list of operators representing the hierarchical basis,
        starting with the seed operator, followed by operators generated by
        successive commutators.
    """
    basis = []
    if seed_op is not None and deep > 0:
        basis += [
            seed_op.to_qutip_operator()
        ]  # Include the seed operator in the basis.
        for _ in range(deep):
            # Generate new operators by computing the commutator
            # of the generator with the last operator.
            basis.append(commutator(generator, 1j * basis[-1]))
    return basis


def fn_hij_tensor(basis, sp: Callable, generator):
    """
    Computes the Hij-tensor, a local matrix representation of the Hamiltonian
    onto the given basis.

    For each pair of basis operators (op1, op2), the matrix element is defined
    as:
        Hij = sp(op1, commutator(-1j * generator, op2))

    Parameters:
        basis: A list of basis operators.
        sp: A callable that defines a scalar product function between two
        operators.
        generator: The operator (e.g., Hamiltonian) for which the commutators
        are computed.

    Returns:
        A real-valued NumPy array representing the Hamiltonian matrix in the
        given basis.
    """
    local_h_ij = np.array(
        [[sp(op1, commutator(-1j * generator, op2)) for op2 in basis] for op1 in basis]
    )
    return np.real(local_h_ij)


def fn_hij_tensor_with_errors(basis, sp: Callable, generator):
    """Compute the tensor Hij and the norm of the orthogonal projection"""
    hgen = -1j * generator
    comm_h_ops = [commutator(hgen, op2).simplify() for op2 in basis]

    local_h_ij = np.zeros([len(basis), len(basis)], dtype=complex)
    for i, b in enumerate(basis):
        for j, comm_op in enumerate(comm_h_ops):
            res = sp(b, comm_op)
            local_h_ij[i, j] = res

    # local_h_ij = np.array(
    #    [[sp(op1, comm_op) for comm_op in comm_h_ops] for op1 in basis]
    # )
    proj_comm_norms_sq = (sum(col**2) for col in local_h_ij.transpose())
    comm_full_norms_sq = (sp(comm_op, comm_op) for comm_op in comm_h_ops)
    errors_w = [
        (max(full_sq - proj_sq, 0.0)) ** 0.5
        for full_sq, proj_sq in zip(comm_full_norms_sq, proj_comm_norms_sq)
    ]
    return local_h_ij, errors_w


def gram_matrix(basis, sp: Callable):
    """
    Computes the Gram matrix of a given operator basis using a scalar product.

    The Gram matrix is symmetric and defined as:
        Gij = sp(op1, op2)
    where `sp` is the scalar product function and `op1, op2` are operators from
    the basis.

    Parameters:
        basis: A list of basis operators.
        sp: A callable that defines a scalar product function between two
        operators.

    Returns:
        A symmetric NumPy array representing the Gram matrix, with entries
        rounded to 14 decimal places.
    """
    size = len(basis)
    result = np.zeros([size, size], dtype=float)

    for i, op1 in enumerate(basis):
        for j, op2 in enumerate(basis):
            if j < i:
                continue  # Use symmetry: Gij = Gji.
            entry = np.real(sp(op1, op2))
            if i == j:
                result[i, i] = entry  # Diagonal elements.
            else:
                result[i, j] = result[j, i] = entry  # Off-diagonal elements.

    return result.round(14)


def orthogonalize_basis(basis, sp: callable, tol=1e-5):
    """
    Orthogonalize a given basis of operators using the default method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two
        operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality
        of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect
        to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy
        orthonormality within the specified tolerance.
    """
    return orthogonalize_basis_gs(basis, sp, tol)


def orthogonalize_basis_gs(basis, sp: callable, tol=1e-5):
    """
    Orthogonalizes a given basis of operators using a scalar product and the
    Gram-Schmidt method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two
        operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality
        of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect
        to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy
        orthonormality within the specified tolerance.
    """
    orth_basis = []
    for op_orig in basis:
        norm: float = abs(sp(op_orig, op_orig)) ** 0.5
        if norm < tol:
            continue
        changed = False
        new_op = op_orig / norm
        for prev_op in orth_basis:
            overlap = sp(prev_op, new_op)
            if abs(overlap) > tol:
                new_op -= prev_op * overlap
                changed = True
        if changed:
            norm = np.real(sp(new_op, new_op) ** 0.5)
            if norm < tol:
                continue
            new_op = new_op / norm
        orth_basis.append(new_op)
    return orth_basis


def orthogonalize_basis_cholesky(basis, sp: callable, tol=1e-5):
    """
    Orthogonalizes a given basis of operators using a scalar product and the
    Cholesky decomposition
    method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two
        operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality
        of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect
        to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy
        orthonormality within the specified tolerance.
    """
    local_basis = basis

    # Compute the inverse Gram matrix for the given basis
    cholesky_gram_matrix = linalg.cholesky(
        gram_matrix(basis=local_basis, sp=sp), lower=False
    )
    linv_t = linalg.inv(cholesky_gram_matrix).transpose()

    # Construct the orthogonalized basis by linear combinations of
    # the original basis
    orth_basis = [
        sum(local_basis[s] * linv_t[i, s] for s in range(i + 1))
        for i in range(len(local_basis))
    ]

    # Verify the orthogonality by checking that the Gram matrix is
    # approximately the identity matrix
    assert (
        linalg.norm(gram_matrix(basis=orth_basis, sp=sp) - np.identity(len(orth_basis)))
        < tol
    ), "Error: Basis not correctly orthogonalized"

    return orth_basis


def orthogonalize_basis_svd(basis, sp: callable, tol=1e-5):
    """
    Orthogonalizes a given basis of operators using a scalar product and the
    svd decomposition method.

    Parameters:
        basis: A list of operators (or matrices) to be orthogonalized.
        sp: A callable that defines the scalar product function between two
        operators.
        tol: A tolerance value (default: 1e-5) for verifying the orthogonality
        of the resulting basis.

    Returns:
        orth_basis: A list of orthogonalized operators, normalized with respect
        to the scalar product `sp`.

    Raises:
        AssertionError: If the orthogonalized basis does not satisfy
        orthonormality within the specified tolerance.
    """
    local_basis = basis

    # Compute the inverse Gram matrix for the given basis
    inv_gram_matrix = linalg.inv(gram_matrix(basis=local_basis, sp=sp))

    # Construct the orthogonalized basis by linear combinations of
    # the original basis
    orth_basis = [
        sum(
            linalg.sqrtm(inv_gram_matrix)[j][i] * local_basis[j]
            for j in range(len(local_basis))
        )
        for i in range(len(local_basis))
    ]

    # Verify the orthogonality by checking that the Gram matrix is
    # approximately the identity matrix
    assert (
        linalg.norm(gram_matrix(basis=orth_basis, sp=sp) - np.identity(len(orth_basis)))
        < tol
    ), "Error: Basis not correctly orthogonalized"

    return orth_basis


def project_op(op, orthogonal_basis, sp: Callable):
    """
    Projects an operator onto an orthogonal basis using a scalar product.

    This computes the components of the orthogonal projection of `op`
    over the basis `orthogonal_basis` with respect to the scalar product `sp`.

    Parameters:
        op: The operator to be projected (e.g., a matrix or quantum operator).
        orthogonal_basis: A list of orthogonalized operators to serve as the
        projection basis.
        sp: A callable that defines the scalar product function between
        two operators.

    Returns:
        A NumPy array containing the projection coefficients, where the i-th
        coefficient represents the projection of `op` onto the i-th element
        of `orthogonal_basis`.
    """
    return np.array([sp(op2, op) for op2 in orthogonal_basis])


def k_state_from_phi_basis(phi: np.array, basis):
    """
    Constructs the operator K from a given set of coefficients and
    basis operators.

    Parameters:
        phi: A NumPy array containing the coefficients for the linear
             combination.
        basis: A list of basis operators.

    Returns:
        The operator K, defined as the negative linear combination of the basis
        operators weighted by the coefficients in `phi`. If `phi` is shorter
        than the basis, it is padded with zeros.
    """
    if len(phi) < len(basis):
        phi = np.array(list(phi) + [0.0 for _ in range(len(basis) - len(phi))])
    return -sum(phi_a * opa for phi_a, opa in zip(phi, basis))


def mft_state_it(k_op, sigma=None, max_it=100):
    """
    Iteratively computes the one-body component from a QuTip operator and state
    using a self-consistent Mean-Field Projection (MF).

    Parameters:
        k_op: The initial operator, a QuTip.Qobj, to be decomposed into
        one-body components.
        sigma: The referential state to be used in the calculations.
        k_0: if given, the logarithm of sigma.
        max_it: Maximum number of iterations.

    Returns:
        A tuple (K_one_body, sigma_one_body):
        - K_one_body: The one-body component of the operator K, an
        AlpsQuTip.one_body_operator object.
        - sigma_one_body: The one-body state normalized through the
        MFT process.
    """
    if sigma is None:
        sigma = GibbsProductDensityOperator(k={}, system=k_op.system)
        neg_log_sigma = -sigma.logm()
    else:
        neg_log_sigma = -sigma.logm()
        if not isinstance(sigma, GibbsProductDensityOperator):
            sigma = GibbsProductDensityOperator(neg_log_sigma)

    rel_s = 10000

    for it in range(max_it):
        k_one_body = project_operator_to_m_body(k_op, 1, sigma)
        new_sigma = GibbsProductDensityOperator(k_one_body)
        k_one_body = new_sigma.logm()
        rel_s_new = np.real(sigma.expect(k_op - k_one_body))
        rel_entropy_txt = f"     S(curr||target)={rel_s_new}"
        logging.debug(rel_entropy_txt)
        if it > 5 and rel_s_new > 2 * rel_s:
            break
        rel_s = rel_s_new
        sigma = new_sigma

    return k_one_body, sigma


def slice_times(tlist: np.array, tcuts):
    """
    Divides a time list (`tlist`) into slices based on a sequence of cutoff
    times (`tcuts`).

    Parameters:
        tlist: A NumPy array of time values to be sliced.
        tcuts: A list or array of cutoff times used to define the time slices.

    Returns:
        A list of NumPy arrays, where each array corresponds to a segment of
        `tlist`
        based on the intervals defined by `tcuts`.
        - The first slice includes times up to `tcuts[1]`.
        - Subsequent slices include times between `tcuts[d-1]` and `tcuts[d]`.
        - If there are remaining times beyond `tcuts[-1]`, they are included
        in the last slice.
    """
    sliced_times = [np.array([t for t in tlist if t <= tcuts[1]])]

    for d in range(2, len(tcuts)):
        local_tlist = np.array([t for t in tlist if tcuts[d - 1] <= t <= tcuts[d]])
        sliced_times.append(local_tlist)

    if tlist[-1] > tcuts[-1]:
        sliced_times.append(np.array([t for t in tlist if t >= tcuts[-1]]))

    return sliced_times


def m_th_partial_sum(phi, m=int):
    """
    Computes the $m$-th partial sum of the squared magnitudes of the last `m`
    coefficients of `phi`.

    Parameters:
        phi: A NumPy array containing coefficients.
        m: An integer specifying how many of the last coefficients to include
        in the sum.

    Returns:
        The partial sum of the squared magnitudes of the last `m` coefficients
        in `phi`.
    """
    return sum(abs(phi_n) ** 2 for phi_n in phi[-m:])


def project_operator_to_m_body(full_operator: Operator, m_max=2, sigma_0=None):
    """
    Project a Operator onto a m_max - body operators sub-algebra
    relative to the local states `local_sigmas`.
    If `local_sigmas` is not given, maximally mixed states are assumed.
    """
    assert sigma_0 is None or hasattr(
        sigma_0, "expect"
    ), f"{        type(sigma_0)} invalid"
    if m_max == 0:
        if sigma_0:
            return ScalarOperator(sigma_0.expect(full_operator), full_operator.system)
        return ScalarOperator(full_operator.tr(), full_operator.system)

    if (isinstance(full_operator, OneBodyOperator)) or (
        len(full_operator.acts_over()) <= m_max
    ):
        return full_operator

    system = full_operator.system
    if isinstance(full_operator, SumOperator):
        terms = tuple(
            (
                project_operator_to_m_body(term, m_max, sigma_0)
                for term in full_operator.terms
            )
        )
        return SumOperator(terms, system).simplify()

    if isinstance(full_operator, ProductOperator):
        # reduce op1 (x) op2 (x) op3 ...
        # to <op1> Proj_{m}(op2 (x) op3) +
        #         Delta op1 (x) Proj_{m-1}(op2 (x) op3)
        # and sum the result.
        sites_op = full_operator.sites_op
        first_site, *rest = tuple(sites_op)
        op_first = sites_op[first_site]
        weight_first = op_first
        sigma_rest = sigma_0
        if sigma_0 is not None:
            sigma_rest = sigma_rest.partial_trace(frozenset(rest))
            sigma_first = sigma_0.partial_trace(frozenset(first_site)).to_qutip()
            weight_first = op_first * sigma_first
        else:
            weight_first = weight_first / op_first.dimensions[0][0]

        first_av = weight_first.tr()
        delta_op = LocalOperator(first_site, op_first - first_av, system)
        sites_op_rest = {
            site: op for site, op in sites_op.items() if site != first_site
        }
        rest_prod_operator = ProductOperator(
            sites_op_rest, prefactor=full_operator.prefactor, system=system
        )

        result = delta_op * project_operator_to_m_body(
            rest_prod_operator, m_max - 1, sigma_rest
        )
        if first_av:
            result = result + first_av * project_operator_to_m_body(
                rest_prod_operator, m_max, sigma_rest
            )
        result = result.simplify()
        return result

    if isinstance(full_operator, QutipOperator):
        project_qutip_operator_to_m_body(full_operator, m_max, sigma_0)

    return project_qutip_operator_to_m_body(
        full_operator.to_qutip_operator(), m_max, sigma_0
    )


def project_qutip_operator_to_m_body(full_operator: Operator, m_max=2, sigma_0=None):
    """
    Specialized version for QutipOperators.
    """
    system = full_operator.system
    if full_operator.is_zero:
        return ScalarOperator(0, system)
    assert sigma_0 is None or hasattr(
        sigma_0, "expect"
    ), f"{
        type(sigma_0)} invalid"
    if sigma_0 is None:
        sigma_0 = ProductDensityOperator({}, system=system)
    assert sigma_0 is None or hasattr(
        sigma_0, "expect"
    ), f"{
        type(sigma_0)} invalid"
    if m_max == 0:
        return ScalarOperator(sigma_0.expect(full_operator), system)

    # Reduce a qutip operator
    site_names = full_operator.site_names
    if len(site_names) < 2:
        return full_operator

    names = tuple(sorted(site_names, key=lambda s: site_names[s]))
    firsts, last_site = names[:-1], names[-1]
    rest_sitenames = {site: site_names[site] for site in firsts}

    qutip_ops_firsts, qutip_ops_last = schmidt_dec_firsts_last_qutip_operator(
        full_operator.to_qutip(names)
    )

    sigma_last_qutip = sigma_0.partial_trace(frozenset({last_site})).to_qutip()
    averages = [qutip.expect(sigma_last_qutip, op_loc) for op_loc in qutip_ops_last]
    sigma_firsts = sigma_0.partial_trace(frozenset(rest_sitenames))
    assert hasattr(
        sigma_firsts, "expect"
    ), f"{type(sigma_0)}->{type(sigma_firsts)} invalid"

    firsts_ops = [
        QutipOperator(op_c, names=rest_sitenames, system=system)
        for op_c in qutip_ops_firsts
    ]
    delta_ops = [
        LocalOperator(last_site, op - av, system=system)
        for av, op in zip(averages, qutip_ops_last)
    ]

    terms = []
    for av, delta, firsts_op in zip(averages, delta_ops, firsts_ops):
        reduced_op = project_operator_to_m_body(
            firsts_op, m_max=m_max - 1, sigma_0=sigma_firsts
        )
        if reduced_op:
            new_term = delta * reduced_op
            terms.append(new_term)
        if not av:
            continue

        new_term = project_qutip_operator_to_m_body(
            firsts_op, m_max=m_max, sigma_0=sigma_firsts
        )
        terms.append(ScalarOperator(av, system) * new_term)

    if terms:
        if len(terms) == 1:
            return terms[0]
        return SumOperator(tuple(terms), system).simplify()
    return ScalarOperator(0, full_operator.system)
